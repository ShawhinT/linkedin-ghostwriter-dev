{
  "input": "Managing technical debt when coding with AI. 2 things I consider. 1) my experience with the lang/library and 2) how many times I need to run project.",
  "writing_steps": "Step 1: Purpose and Target Audience\n- Purpose: Educate readers about practical considerations for managing technical debt when coding with AI, specifically focusing on language/library familiarity and project repeatability.\n- Target audience: AI engineers, technical founders, solo developers, and practitioners building AI projects (especially those mindful of maintainability, not just speed).\n\nStep 2: Post Wireframe\n[Hook (above the fold)]\n[2 practical considerations for managing technical debt in AI projects (with explanations for each)]\n[CTA: Invite readers to share any additional factors they use to minimize technical debt]\n\nStep 3: Body\nManaging technical debt with AI is an under-discussed but critical topic. When starting a new project, I always ask myself two questions:\n\n1. How familiar am I with this language or library?\n- If I know the tool well, I can debug faster, skip the documentation dive, and feel confident maintaining the code later.\n- If it’s unfamiliar, the risk is higher—not just for bugs, but for future maintainability.\n\n2. How many times will I need to run this project?\n- If it’s a one-off script, I can tolerate more mess or quick hacks.\n- If I’ll run it often (or if others depend on it), structure and clarity become crucial. Tiny shortcuts lead to big headaches if this turns into production code.\n\nStep 4: CTA/Question\nWhat other factors do you consider to keep technical debt low on your AI projects?\n\nStep 5: Hook Brainstorm\nA. [Problem/solution] Most advice on technical debt is vague. Here’s how I actually make decisions when building AI projects.\nB. [Beginner-to-expert clarity] The two questions I ask before starting any new AI build.\nC. [User’s own phrasing] Managing technical debt when coding with AI: 2 things I consider.\nD. [Trend/urgency] AI projects move fast, but technical debt slows you down—here are the guardrails I use.\nE. [Literal list] 2 ways I manage technical debt when coding with AI.\n\nStep 5B:\nA. Most advice is generic—focus on practical, lived decisions.\nB. Implies actionable, habitual process readers can borrow.\nC. Direct and uses user’s original phrasing.\nD. Urgent but steer away from hype and stick with practical language.\nE. Factual and straightforward; no fluff.\n\nStep 5C: Choose strongest direction and write the hook\n[Beginner-to-expert clarity, literal] The 2 questions I always ask before shipping AI code—to keep technical debt under control.\n\nStep 6: Full Draft\nThe 2 questions I always ask before shipping AI code—to keep technical debt under control.\n\nWhen starting a new project, these are my guardrails:\n\n1. Am I familiar with the language or library I’m using?\n- If yes, I know where pitfalls are and can maintain things later. If not, every shortcut now is future risk.\n\n2. How many times will I need to run this code?\n- One-off project? More flexibility, less structure is fine. Ongoing or repeated use? I design for clarity from the start.\n\nEvery time I ignore one, it costs me later. Every time I stick to both, my code is simpler—and my future self thanks me.\n\nWhat else do you consider to keep technical debt low when building with AI?\n\nStep 7: Review\n- There are no business clichés or idioms.\n- Literal and factual language.\n- Structure and list-format is clear.\n- Hook is factual and curiosity-driven, directly referencing what follows.\n- CTA is single, practical, no \"or\"/\"and\" split. All Language is literal (no “raise the bar” etc.).\n- Clear white space, direct language, aligns with style in example posts.\n- Cross-checked against examples 1, 4, and 5: matches tone, clarity, educational value.\n\nStep 8: Final Post Below.",
  "final_post": "The 2 questions I always ask before shipping AI code—to keep technical debt under control.\n\nWhen kicking off a new project, here are my guardrails:\n\n1. Am I familiar with this language or library?\n    - If yes, I can debug faster and maintain it later. If not, every shortcut now is future risk.\n\n2. How many times will I need to run this code?\n    - For a one-off, I can handle some mess. But if it's a recurring project (or will be used by others), I focus on clarity and structure from the start.\n\nEvery time I ignore one of these, it costs me later. Every time I stick to both, my projects stay maintainable—even as they grow.\n\nWhat else do you consider to keep technical debt low when building with AI?"
}
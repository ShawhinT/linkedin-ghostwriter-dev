{
  "input": "Managing technical debt when coding with AI. 2 things I consider. 1) my experience with the lang/library and 2) how many times I need to run project.",
  "writing_steps": "Step 1: \nPurpose: Educate and share a practical framework for managing technical debt when coding with AI, based on personal experience.\nTarget Audience: AI practitioners, developers, and technical entrepreneurs looking to build smarter and faster with AI tools.\n\nStep 2: \nWireframe:\n[Hook: Call out the problem of technical debt, tease practical framework]\n[Meat: Briefly define technical debt in context of AI projects. Share the 2 main considerations: 1) Experience with language/library, 2) Anticipated frequency of running the project. Explain how each factor impacts decision-making. Share a quick real example (optional).]\n[CTA: Ask the community about their own approach or lessons managing technical debt.]\n\nStep 3: \nBody/Meat:\nWhenever I tackle a new AI project, I’m always thinking about future maintainability—otherwise, technical debt can sneak in fast. Over time, I’ve developed a simple 2-question gut check:\n\n1. How well do I know this language or library? If I’m deep in Python and have built with LangChain before, I’m comfortable moving fast—even roughing out early code. But if I’m less familiar, I’ll slow down and build smaller pieces, with extra comments and tests.\n2. How often will I run this project? For a one-off prototype, speed wins—I let messier code slide. But if it’s something that’ll run every week, I invest upfront in better structure and docstrings, so future-me doesn’t curse present-me.\n\nIt’s not always perfect, but asking these two questions saves me headaches and bloat down the line.\n\nStep 4: \nCTA/Question:\nHow do you manage technical debt on AI projects?\n\nStep 5:\n5A: Brainstorm labeled directions:\n- [Problem/Solution] \"Why technical debt creeps up fast in AI projects—and my two-step gut check.\"\n- [Personal story] \"How realizing my code was unmaintainable forced me to rethink how I start every AI build.\"\n- [Beginner-to-Expert Mythbusting] \"Most people overcomplicate technical debt. Here’s my brutally simple filter.\"\n- [Result-oriented] \"This 2-question rule has saved me dozens of hours refactoring projects.\"\n\n5B: Add notes:\n- Problem/Solution: Many ship prototypes fast with AI, then get stuck maintaining.\n- Personal Story: Share a time when bad choices bit me.\n- Beginner-to-Expert: Distill complexity into 2 questions.\n- Result: Promised time saved.\n\n5C: Choose strongest direction: Beginner-to-Expert mythbusting is direct, actionable, and fits Shaw’s honest/clear style.\n\nHook: Most people overcomplicate technical debt. Here’s my simple 2-question filter.\n\nStep 6: Review\n- Structure is clear (hook/meat/CTA)\n- Body is honest and practical\n- One focused CTA\n- Hook is direct, actionable\n- Language is clear, conversational, technical-peer level\n\nStep 7: See below.",
  "final_post": "Most people overcomplicate technical debt.\nHere’s my simple 2-question filter.\n\nWhenever I tackle a new AI project, I think about future maintainability—otherwise, technical debt sneaks in fast. Here’s my gut check:\n\n1. How well do I know this language or library?  \nIf I’m deep in Python and have built with a framework before, I’ll move fast—even rough out early code. But if it’s unfamiliar, I go slower and build smaller pieces, with more comments and tests.\n\n2. How often will I run this project?  \nFor a one-off prototype, speed wins—I let messier code slide. But if it’s something that’ll run every week, I invest upfront in better structure, tests, and docstrings, so future-me doesn’t curse present-me.\n\nIt’s not perfect—but these two questions have saved me hours of cleaning up later.\n\nHow do you manage technical debt on AI projects?"
}